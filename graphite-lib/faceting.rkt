#lang racket/base
(require pict
         plot/no-gui
         racket/bool
         racket/match
         racket/vector
         "titles.rkt"
         "util.rkt"
         "with-area.rkt")
(provide graph-internal facet-plot)

;; (listof (-> (treeof (or/c renderer2d? nonrenderer?)))) (or/c string? #f)
;;   -> plot-pict?
;; runs plot-pict with the given render functions,
;; parameterizing group so the renderers know how to filter the data
(define (graph-internal render-fns [group #f])
  (plot-pict #:x-min (gr-x-min)
             #:x-max (gr-x-max)
             #:y-min (gr-y-min)
             #:y-max (gr-y-max)
             (parameterize ([gr-group group])
               (for/list ([render-fn (in-list render-fns)])
                 (render-fn)))))

;; (listof (-> (treeof (or/c renderer2d? nonrenderer?)))) (or/c exact-positive-integer? #f)
;;   -> pict?
;;
;; lays out a wrapped facet on the variable in the global mapping 'facet, with the max
;; row width wrap
;;
;; XXX: this whole thing is WIP
;;      maybe ppicts would help out?
;; TODO: multifaceting (facet-grid)
;; TODO: disjoint axes
(define (facet-plot render-fns wrap)
  ;; get the facet variable, and the possibilities of that facet variable
  (define facet (hash-ref (gr-global-mapping) 'facet))
  (define groups (possibilities (gr-data) facet))

  ;; if a wrap is not specified by the main `graph` form, set it to ceiling of √(length groups)
  ;; since this induces a "horizontally-focused" grid (which is usually what you want)
  (define facet-wrap (or wrap (inexact->exact (ceiling (sqrt (vector-length groups))))))
  ;; turns groups into "wrapped" groups by row, so (1 2 3 4 5) with a wrap of 2 turns into
  ;; (1 2 3)
  ;; (4 5 #f)
  ;; where each #f is then a blank square in the result
  (define wrapped-groups (vector-reshape groups facet-wrap))
  ;; get the number of #fs that were generated by the last call
  ;; all #fs will be in the last row, so just get the last row
  (define num-blanks
    (vector-count not (vector-ref
                       wrapped-groups
                       (sub1 (vector-length wrapped-groups)))))

  ;; (boolean?) (boolean?)
  ;;   -> (values plot-pict? positive-real? positive-real? positive-real? positive-real?)
  ;; gives information about the extras size of the given plot, as well as giving back the plot
  (define (get-extra-metrics #:x-ticks? [x-ticks? #t] #:y-ticks? [y-ticks? #t])
    ;; run the plot with no titles, and remove facet to avoid filtering with no group
    (define metrics-plot
      (parameterize ([gr-global-mapping (hash-remove (gr-global-mapping) 'facet)]
                     [plot-x-ticks (if x-ticks? (plot-x-ticks) no-ticks)]
                     [gr-add-x-ticks? x-ticks?]
                     [plot-y-ticks (if y-ticks? (plot-y-ticks) no-ticks)]
                     [gr-add-y-ticks? y-ticks?])
        (graph-internal render-fns)))
    (apply values metrics-plot (call-with-values (λ () (plot-extras-size metrics-plot)) list)))

  ;; get some numbers, for alignment
  ;; 1. get all the padding, as well as get the x-min/y-max of all the combined data
  ;;    we don't want plot to infer stuff, since we want common axes on all frames
  (define-values (metrics-plot all-left all-right all-bot all-top)
    (get-extra-metrics))
  (match-define (vector (vector x-min x-max)
                        (vector y-min y-max))
    (plot-pict-bounds metrics-plot))
  ;; 2. get padding without y-ticks, so we know how much the x-ticks extend the plot left/right
  (match-define-values (_ x-left x-right _ _)
                       (get-extra-metrics #:x-ticks? #t))
  ;; 3. get padding without x-ticks, so we know how much the x-ticks extend the plot up/down
  (match-define-values (_ _ _ y-bot y-top)
                       (get-extra-metrics #:y-ticks? #t))
  ;; 4. get the height of a title pict, which are appended on later
  ;;    (we don't really care about the width)
  (define title-height (pict-height (title "abcdefg")))

  ;; p rows by q columns
  (define grid-p (vector-length wrapped-groups))
  (define grid-q (vector-length (vector-ref wrapped-groups 0)))

  ;; anatomy of a facet (ytc = y-ticks)
  ;;        fulltitle
  ;;      title    title
  ;;     +-----+  +-----+
  ;;   y |     |  |     |
  ;;   t |     |  |     |
  ;; y c |     |  |     |
  ;; -   +-----+  +-----+
  ;; l    title    ticks
  ;; a   +-----+
  ;; b y |     |
  ;;   t |     |
  ;;   c |     |
  ;;     +-----+
  ;;      ticks
  ;;           x-lab
  ;;
  ;; so, if a plot must have total width W and height H,
  ;;     p rows, and q columns,
  ;; then W = title-height           ; y-label
  ;;        + all-left               ; leftmost plots with ticks
  ;;        + (all-right * q)        ; one right extra for each column
  ;;        + (x-left * (q - 1))     ; one left extra for each non-initial column
  ;;        + (q * INT-W)            ; internal plot width
  ;; and  H = (2 * title-height)     ; full title, x-label
  ;;        + (p * title-height)     ; facet labels for each row
  ;;        + all-bot                ; bottom-most plot with ticks
  ;;        + (y-bot * (p - 1))      ; bottom extras for each non-initial row
  ;;        + (p * INT-H)            ; internal plot height
  ;; note that top extras are elided due to the way titles are added
  ;; XXX: temporarily assuming all of these variables are present -- many can be
  ;;      configured out
  ;;      at worst it's an overapproximation, and we have some extra whitespace
  ;;      but then we need to normalize that whitespace... aaargh
  (define width (inexact->exact
                 (ceiling (/ (- (plot-width)
                                title-height
                                all-left
                                (* grid-q all-right)
                                (* (sub1 grid-q) x-left))
                             grid-q))))
  (define height (inexact->exact
                  (ceiling (/ (- (plot-height)
                                 (* 2 title-height)
                                 (* grid-p title-height)
                                 all-bot
                                 (* (sub1 grid-p)  y-bot))
                              grid-p))))

  ;; string? (boolean?) (boolean?) -> (values (or/c string? #f) plot-pict?)
  ;; runs a single plot on a single group
  (define (run-plot group [with-x-extras? #f] [with-y-extras? #f])
    (parameterize ([plot-x-ticks (if with-x-extras? (plot-x-ticks) no-ticks)]
                   [gr-add-x-ticks? with-x-extras?]
                   [plot-x-label (and with-x-extras? (plot-x-label))]
                   [plot-y-ticks (if with-y-extras? (plot-y-ticks) no-ticks)]
                   [gr-add-y-ticks? with-y-extras?]
                   [plot-y-label (and with-y-extras? (plot-y-label))])
      (if group
          (values group
                  (plot-with-area (λ () (graph-internal render-fns group)) width height))
          (values #f (blank width (+ height all-bot title-height))))))

  ;; runs each plot, turning them into a list of picts
  ;; first, parameterize the global x-min/x-max, so we have consistent axes
  ;; NOTE: this is where we'd do disjointness fixes
  ;;       qualitative variables would need more work
  (define all-plots
    (parameterize ([gr-x-min (or (gr-x-min) x-min)]
                   [gr-x-max (or (gr-x-max) x-max)]
                   [gr-y-min (or (gr-y-min) y-min)]
                   [gr-y-max (or (gr-y-max) y-max)])
      ;; for each row, and each column within each row...
      (for*/list ([(grp-vector grp-vector-idx) (in-indexed (in-vector wrapped-groups))]
                  [(group group-idx) (in-indexed (in-vector grp-vector))])
        ;; number of rows off from the end
        (define offset (- (sub1 grid-p) grp-vector-idx))
        ;; add x extras if we're at the end,
        ;; or if we're at the bottom and we've reached the blanks
        (define add-x-extras? (or (zero? offset)
                                  (and (= offset 1)
                                       (< (abs (- grid-q (add1 group-idx))) num-blanks))))
        ;; add y extras if we're at the first column
        (define-values (grp plt) (run-plot group add-x-extras? (zero? group-idx)))
        ;; add facet labels if we have anything but a blank. if we have a blank, don't bother
        (if grp (add-facet-label grp plt) plt))))

  ;; combine all-plots into a table, without adding global titles/axis labels
  (define untitled
    (table grid-q all-plots cc-superimpose lt-superimpose
           (list* 0 (max all-left all-right))
           (build-list (sub1 grid-p)
                       (λ (x) (if (and (not (zero? num-blanks))
                                       (= x (- grid-p 2)))
                                  (- (plot-line-width) all-bot)
                                  (plot-line-width))))))

  ;; add global titles and axis labels to the entire pict
  (add-all-titles untitled
                  #:x-offset (- (+ all-right all-left
                                   (if (gr-y-label) title-height 0)))
                  #:y-offset (- (+ all-top all-bot
                                   (if (xor (gr-title) (gr-x-label)) title-height 0)))))
